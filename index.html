<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Milsim Map Viewer 2.1</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #1b1b1b;
      color: #f0f0f0;
    }

    :root {
      --ui-scale: 1.5;
    }

    /* Startup overlay */
    #startupOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }

    .startup-dialog {
      background: #242424;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 1.5rem 2rem;
      max-width: 420px;
      width: 100%;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
    }

    .startup-dialog h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1.3rem;
    }

    .startup-dialog label {
      display: block;
      margin: 0.5rem 0 0.25rem;
      font-size: 0.9rem;
    }

    .startup-dialog input[type="file"] {
      width: 100%;
      margin-bottom: 0.75rem;
    }

    .startup-dialog button {
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.4rem 0.9rem;
      border-radius: 4px;
      border: 1px solid #666;
      background: #3a3a3a;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.95rem;
    }

    .startup-dialog button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .startup-dialog button:not(:disabled):hover {
      background: #4a4a4a;
    }

    /* Top toolbar */
    .toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem 1rem;
      background: #242424;
      border-bottom: 1px solid #444;
      font-size: 0.9rem;
      z-index: 100;
      transform: scale(var(--ui-scale));
      transform-origin: top left;
    }

    .toolbar label {
      font-size: 0.9rem;
    }

    .toolbar input[type="file"] {
      margin-left: 0.25rem;
    }

    .toolbar button {
      padding: 0.35rem 0.75rem;
      border: 1px solid #555;
      background: #333;
      color: #f0f0f0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .toolbar button:hover {
      background: #3f3f3f;
    }

    .toolbar button.active {
      background: #5a5a5a;
      border-color: #bbb;
    }

    .toolbar input[type="number"] {
      width: 4rem;
      padding: 0.2rem 0.3rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #1a1a1a;
      color: #f0f0f0;
    }

    #scaleDisplay {
      font-size: 0.85rem;
      opacity: 0.8;
    }

    #measureInfo {
      font-size: 0.85rem;
      opacity: 0.9;
    }

    /* Help / keybinds menu */
    #helpMenuWrapper {
      margin-left: auto;
      position: relative;
    }

    #helpMenuBtn {
      padding: 0.25rem 0.55rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #333;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }

    #helpMenuBtn:hover {
      background: #3f3f3f;
    }

    .help-menu {
      position: absolute;
      right: 0;
      top: 120%;
      background: #2c2c2c;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      min-width: 280px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
      font-size: 0.8rem;
      display: none;
      z-index: 200;
    }

    .help-menu.open {
      display: block;
    }

    .help-menu-header {
      font-weight: bold;
      margin-bottom: 0.4rem;
      border-bottom: 1px solid #444;
      padding-bottom: 0.25rem;
    }

    .help-menu ul {
      list-style: disc;
      margin: 0.25rem 0 0;
      padding-left: 1.1rem;
    }

    .help-menu li {
      margin: 0.15rem 0;
      line-height: 1.25;
    }

    .help-menu code {
      font-family: Consolas, monospace;
      font-size: 0.8rem;
      background: #1a1a1a;
      padding: 0 2px;
      border-radius: 2px;
    }

    .help-menu a {
      color: #4da6ff;
      text-decoration: none;
    }

    .help-menu a:hover {
      text-decoration: underline;
    }

    /* Layout */
    #mainArea {
      display: flex;
      height: calc(100vh - 50px);
      margin-top: 50px;
    }

    /* Symbol bin */
    #symbolBin {
      position: fixed;
      top: 60px;
      left: 8px;
      width: 220px;
      border: 1px solid #444;
      background: rgba(32, 32, 32, 0.95);
      padding: 0.6rem;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      border-radius: 6px;
      z-index: 20;
      transform: scale(var(--ui-scale));
      transform-origin: top left;
    }

    #symbolBin h3 {
      margin: 0 0 0.3rem;
      font-size: 0.95rem;
      border-bottom: 1px solid #444;
      padding-bottom: 0.3rem;
    }

    .symbol-btn,
    #addCustomSymbolBtn {
      width: 100%;
      padding: 0.35rem 0.4rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #313131;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.85rem;
      text-align: left;
    }

    .symbol-btn:hover,
    #addCustomSymbolBtn:hover {
      background: #3c3c3c;
    }

    /* Dropdown buttons */
    #generalDropdownBtn,
    #platoonDropdownBtn {
      width: 100%;
      padding: 0.35rem 0.4rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #313131;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.85rem;
      text-align: left;
    }

    #generalDropdownBtn:hover,
    #platoonDropdownBtn:hover {
      background: #3c3c3c;
    }

    #generalDropdown,
    #platoonDropdown {
      display: none;
      flex-direction: column;
      gap: 4px;
      margin: 4px 0;
    }

    #generalDropdown.open,
    #platoonDropdown.open {
      display: flex;
    }

    .inf-unit-btn {
      width: 100%;
      padding: 0.3rem 0.35rem;
      border-radius: 4px;
      border: 1px solid #444;
      background: #262626;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.8rem;
      text-align: left;
    }

    .inf-unit-btn:hover {
      background: #333333;
    }

    /* Icon size control */
    #iconScaleControl {
      margin-top: 0.25rem;
      padding-top: 0.35rem;
      border-top: 1px solid #444;
      font-size: 0.85rem;
    }

    #iconScaleSlider {
      width: 100%;
      margin-top: 0.25rem;
    }

    #mapWrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #mapContainer {
      flex: 1;
      position: relative;
      background: #111;
      overflow: auto;
      scroll-behavior: smooth;
      cursor: default;
    }

    #mapZoomWrapper {
      position: relative;
      display: inline-block;
    }

    #mapInner {
      position: relative;
      display: block;
      transform-origin: top left;
    }

    #mapImage {
      display: block;
      border-right: 1px solid #444;
      border-bottom: 1px solid #444;
      z-index: 0;
      position: absolute;
      top: 0;
      left: 0;
    }

    .overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    #gridCanvas {
      z-index: 1;
    }

    #drawCanvas {
      z-index: 2;
    }

    #measureCanvas {
      z-index: 3;
    }

    #statusBar {
      height: 26px;
      padding: 4px 8px;
      font-size: 0.8rem;
      background: #202020;
      border-top: 1px solid #444;
      box-sizing: border-box;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Tokens / assets */
    .token {
      position: absolute;
      width: 48px;
      height: 48px;
      cursor: move;
      user-select: none;
      -webkit-user-drag: none;
      box-sizing: border-box;
      z-index: 5;
      transform-origin: center center;
    }

    .token img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .token-label {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: bold;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      text-align: center;
      padding: 2px;
      overflow: hidden;
    }

    .symbol-objective {
      background: #7a0000;
      color: #ffffff;
    }

    .symbol-lz {
      background: #005f3c;
      color: #ffffff;
    }

    .symbol-fob {
      background: #008b8b;
      color: #ffffff;
    }

    .token.selected-token {
      outline: 2px solid #00ffff;
    }

    /* Friendly infantry marker */
    .friendly-unit {
      width: 56px;
      height: 72px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    .friendly-box {
      width: 48px;
      height: 32px;
      background: #1bb4d6;
      border: 2px solid #000000;
      border-radius: 4px;
      position: relative;
      box-sizing: border-box;
      background-image:
        linear-gradient(45deg,
          transparent calc(50% - 1px),
          #000000 calc(50% - 1px),
          #000000 calc(50% + 1px),
          transparent calc(50% + 1px)),
        linear-gradient(-45deg,
          transparent calc(50% - 1px),
          #000000 calc(50% - 1px),
          #000000 calc(50% + 1px),
          transparent calc(50% + 1px));
      background-repeat: no-repeat;
      background-size: 100% 100%;
    }

    .friendly-unit-id {
      margin-top: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      color: #ffffff;
      text-shadow: 0 0 2px #000000;
      white-space: nowrap;
    }

    /* Enemy infantry marker */
    .enemy-unit {
      width: 56px;
      height: 72px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    .enemy-diamond {
      width: 32px;
      height: 32px;
      background: #cc0000;
      border: 2px solid #000000;
      position: relative;
      transform: rotate(45deg);
      box-sizing: border-box;
    }

    .enemy-diamond::before,
    .enemy-diamond::after {
      content: "";
      position: absolute;
      background: #000000;
    }

    /* line mid-edge to mid-edge (horizontal) */
    .enemy-diamond::before {
      left: 0;
      top: 50%;
      width: 100%;
      height: 2px;
      transform: translateY(-50%);
    }

    /* line mid-edge to mid-edge (vertical) */
    .enemy-diamond::after {
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      transform: translateX(-50%);
    }

    .enemy-unit-id {
      margin-top: 3px;
      font-size: 0.65rem;
      font-weight: bold;
      color: #ffffff;
      text-shadow: 0 0 2px #000000;
      white-space: nowrap;
    }

    /* Bottom-right controls */
    #mapControlsPanel {
      position: fixed;
      bottom: 8px;
      right: 8px;
      background: rgba(32, 32, 32, 0.95);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 6px;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
      z-index: 20;
      transform: scale(var(--ui-scale));
      transform-origin: bottom right;
    }

    #deleteSelect {
      max-width: 180px;
      background: #1a1a1a;
      color: #f0f0f0;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 0.8rem;
      padding: 2px 4px;
    }

    #deleteSelectedBtn,
    #clearAllBtn {
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #333;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.8rem;
    }

    #deleteSelectedBtn:hover,
    #clearAllBtn:hover {
      background: #3f3f3f;
    }

    /* Bottom-left coordinate panel */
    #coordPanel {
      position: fixed;
      bottom: 8px;
      left: 8px;
      background: rgba(32, 32, 32, 0.95);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 0.8rem;
      z-index: 20;
      transform: scale(var(--ui-scale));
      transform-origin: bottom left;
      white-space: nowrap;
    }

    /* Scale modal */
    #scaleModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 998;
    }

    #scaleModal {
      background: #242424;
      border: 1px solid #555;
      border-radius: 8px;
      padding: 1rem 1.5rem;
      max-width: 320px;
      width: 100%;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
      font-size: 0.9rem;
    }

    #scaleModal h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    #scaleModal label {
      display: block;
      margin-top: 0.5rem;
    }

    #scaleModal input[type="number"],
    #scaleModal select {
      width: 100%;
      margin-top: 0.25rem;
      padding: 0.25rem 0.4rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #1a1a1a;
      color: #f0f0f0;
    }

    #scalePxDistanceInfo {
      margin: 0 0 0.5rem;
      font-size: 0.85rem;
      opacity: 0.9;
    }

    #scaleModalButtons {
      margin-top: 0.75rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }

    #scaleModalButtons button {
      padding: 0.3rem 0.8rem;
      border-radius: 4px;
      border: 1px solid #555;
      background: #333;
      color: #f0f0f0;
      cursor: pointer;
      font-size: 0.85rem;
    }

    #scaleModalButtons button:hover {
      background: #3f3f3f;
    }
  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    if (window["pdfjsLib"]) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }
  </script>
</head>
<body>
  <!-- Startup overlay -->
  <div id="startupOverlay">
    <div class="startup-dialog">
      <h2>Set up your map</h2>
      <p style="font-size:0.9rem; opacity:0.9;">
        Choose your map file (image or PDF).  
        After that, click “Confirm &amp; View Map” to load it.

      <label for="startupMapUpload">Map file (JPEG/PNG/PDF):</label>
      <input type="file" id="startupMapUpload" accept="image/*,application/pdf" />
      </p>
        <p style="font-size:0.9rem; opacity:0.9; margin-top:8px;">
        Navigation Note: Use the bottom slider bar to move left and right, and use the mouse scroll wheel to move up and down.
      </p>
      <button id="startupStartBtn" disabled>Confirm &amp; View Map</button>
    </div>
  </div>

  <!-- Scale modal -->
  <div id="scaleModalOverlay">
    <div id="scaleModal">
      <h3>Set Scale from Distance</h3>
      <p id="scalePxDistanceInfo"></p>
      <label>
        Known distance:
        <input type="number" id="scaleKnownDistance" step="0.01" min="0.0001" />
      </label>
      <label>
        Units:
        <select id="scaleUnit">
          <option value="meters" selected>Meters</option>
          <option value="yards">Yards</option>
        </select>
      </label>
      <div id="scaleModalButtons">
        <button id="scaleCancelBtn">Cancel</button>
        <button id="scaleConfirmBtn">Set Scale</button>
      </div>
    </div>
  </div>

  <!-- Top toolbar -->
  <div class="toolbar">
    <label>
      Map:
      <input type="file" id="mapUpload" accept="image/*,application/pdf" />
    </label>

    <label>
      Scale: 1 px =
      <input type="number" id="scaleInput" step="0.01" min="0.0001" />
      m
    </label>
    <span id="scaleDisplay"></span>

    <label>
      UI Scale:
      <select id="uiScaleSelect">
        <option value="2">1x</option>
        <option value="3">1.5x</option>
        <option value="4">2x</option>
        <option value="8">4x</option>
        <option value="1">0.5x</option>
        <option value="0.5">0.25x</option>
        <option value="0.2">0.1x</option>
      </select>
    </label>

    <button id="originBtn">Set Origin (0,0)</button>
    <button id="setScaleBtn">Set Scale by 2 Points</button>
    <button id="measureBtn">Measure</button>
    <button id="penBtn">Pen</button>
    <button id="lineBtn">Line</button>
    <button id="circleBtn">Circle</button>
    <button id="arrowBtn">Arrow</button>

    <label>
      Line Width:
      <input type="number" id="penWidthInput" min="1" max="20" value="8" />
    </label>

    <label>
      Arrow Width:
      <input type="number" id="arrowWidthInput" min="1" max="20" value="8" />
    </label>

    <span id="measureInfo"></span>

    <div id="helpMenuWrapper">
      <button id="helpMenuBtn" title="Controls & Keybinds">?</button>
      <div id="helpMenu" class="help-menu">
        <div class="help-menu-header">Controls &amp; Keybinds</div>
        <ul>
          <li><strong>Navigation</strong></li>
          <li><code>Shift</code> + Mouse Wheel – Zoom in/out at cursor</li>
          <li><code>Ctrl</code> + <code>Z</code> – Undo last action</li>
          <li>&nbsp;</li>
          <li><strong>Icons</strong></li>
          <li>Left-click icon – Select</li>
          <li>Left-click + drag icon – Move (only when no tools are active)</li>
          <li><code>←</code> / <code>→</code> (with icon selected) – Rotate selected icon(s)</li>
          <li><code>Ctrl</code> + Right-click icons – Multi-select</li>
          <li>&nbsp;</li>
          <li><strong>Drawing Tools</strong></li>
          <li><strong>Pen:</strong> Hold Left-click to draw, release to stop; Right-click to exit Pen mode</li>
          <li><strong>Line / Arrow:</strong> Left-click to add points; Right-click to finish</li>
          <li><strong>Circle:</strong> Left-click center, then edge; Right-click to exit Circle mode</li>
          <li><strong>Measure:</strong> Left-click two points to get distance</li>
          <li><strong>Origin:</strong> Click map to set and assign coordinates</li>
          <li>&nbsp;</li>
          <li><strong>Creator Info</strong></li>
          <li>Discord: <code>@LickyMyBlicky</code></li>
          <li>YouTube: <a href="https://www.youtube.com/@LickyMyBlicky" target="_blank">youtube.com/@LickyMyBlicky</a></li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Main area -->
  <div id="mainArea">
    <!-- Symbol bin -->
    <div id="symbolBin">
      <h3>Symbols</h3>

      <!-- General Units -->
      <button id="generalDropdownBtn">General Units ▾</button>
      <div id="generalDropdown">
        <button class="inf-unit-btn" data-side="friendly" data-label="">Friendly INF (generic)</button>
        <button class="inf-unit-btn" data-side="enemy" data-label="">Enemy INF (generic)</button>
      </div>

      <!-- 1st Platoon -->
      <button id="platoonDropdownBtn">1st Platoon ▾</button>
      <div id="platoonDropdown">
        <button class="inf-unit-btn" data-side="friendly" data-label="1-1">1-1</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-1A">1-1A</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-1B">1-1B</button>

        <button class="inf-unit-btn" data-side="friendly" data-label="1-2">1-2</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-2A">1-2A</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-2B">1-2B</button>

        <button class="inf-unit-btn" data-side="friendly" data-label="1-3">1-3</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-3A">1-3A</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-3B">1-3B</button>

        <button class="inf-unit-btn" data-side="friendly" data-label="1-4">1-4</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-4A">1-4A</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-4B">1-4B</button>

        <button class="inf-unit-btn" data-side="friendly" data-label="1-6">1-6</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-6A">1-6A</button>
        <button class="inf-unit-btn" data-side="friendly" data-label="1-6B">1-6B</button>
      </div>

      <!-- Simple click assets -->
      <button class="symbol-btn" data-symbol="objective">OBJ – Objective</button>
      <button class="symbol-btn" data-symbol="lz">LZ – Landing Zone</button>
      <button class="symbol-btn" data-symbol="fob">FOB – Base</button>

      <button id="addCustomSymbolBtn">+ Custom Icon (PNG/JPEG)</button>

      <!-- Icon size control (slider) -->
      <div id="iconScaleControl">
        Icon Size:
        <input
          type="range"
          id="iconScaleSlider"
          min="0.5"
          max="2"
          step="0.25"
          value="1"
        />
        <div id="iconScaleValue">1.0x</div>
      </div>
    </div>

    <!-- Map -->
    <div id="mapWrapper">
      <div id="mapContainer">
        <div id="mapZoomWrapper">
          <div id="mapInner">
            <img id="mapImage" alt="Map will appear here" />
            <canvas id="gridCanvas" class="overlayCanvas"></canvas>
            <canvas id="drawCanvas" class="overlayCanvas"></canvas>
            <canvas id="measureCanvas" class="overlayCanvas"></canvas>
          </div>
        </div>
      </div>
      <div id="statusBar">Cursor: – (load a map, then set scale to enable grid)</div>
    </div>
  </div>

  <!-- Bottom-right controls -->
  <div id="mapControlsPanel">
    <select id="deleteSelect">
      <option value="">Delete element…</option>
    </select>
    <button id="deleteSelectedBtn">Delete</button>
    <button id="clearAllBtn">Clear All</button>
  </div>

  <!-- Bottom-left coordinate panel -->
  <div id="coordPanel">X: –, Y: –</div>

  <!-- Hidden input for custom symbols -->
  <input type="file" id="tokenUpload" accept="image/*" style="display:none;" />

  <script>
    // DOM refs
    const startupOverlay = document.getElementById("startupOverlay");
    const startupMapUpload = document.getElementById("startupMapUpload");
    const startupStartBtn = document.getElementById("startupStartBtn");

    const mapUpload = document.getElementById("mapUpload");
    const scaleInput = document.getElementById("scaleInput");
    const scaleDisplay = document.getElementById("scaleDisplay");

    const uiScaleSelect = document.getElementById("uiScaleSelect");

    const originBtn = document.getElementById("originBtn");
    const setScaleBtn = document.getElementById("setScaleBtn");
    const measureBtn = document.getElementById("measureBtn");
    const penBtn = document.getElementById("penBtn");
    const lineBtn = document.getElementById("lineBtn");
    const circleBtn = document.getElementById("circleBtn");
    const arrowBtn = document.getElementById("arrowBtn");

    const penWidthInput = document.getElementById("penWidthInput");
    const arrowWidthInput = document.getElementById("arrowWidthInput");
    const measureInfo = document.getElementById("measureInfo");

    const symbolButtons = document.querySelectorAll(".symbol-btn");
    const generalDropdownBtn = document.getElementById("generalDropdownBtn");
    const generalDropdown = document.getElementById("generalDropdown");
    const platoonDropdownBtn = document.getElementById("platoonDropdownBtn");
    const platoonDropdown = document.getElementById("platoonDropdown");
    const addCustomSymbolBtn = document.getElementById("addCustomSymbolBtn");
    const tokenUpload = document.getElementById("tokenUpload");
    const iconScaleSlider = document.getElementById("iconScaleSlider");
    const iconScaleValue = document.getElementById("iconScaleValue");

    const helpMenuBtn = document.getElementById("helpMenuBtn");
    const helpMenu = document.getElementById("helpMenu");

    const mapImage = document.getElementById("mapImage");
    const mapInner = document.getElementById("mapInner");
    const mapZoomWrapper = document.getElementById("mapZoomWrapper");
    const mapContainer = document.getElementById("mapContainer");
    const gridCanvas = document.getElementById("gridCanvas");
    const drawCanvas = document.getElementById("drawCanvas");
    const measureCanvas = document.getElementById("measureCanvas");
    const statusBar = document.getElementById("statusBar");

    const mainArea = document.getElementById("mainArea");
    const symbolBin = document.getElementById("symbolBin");
    const toolbar = document.querySelector(".toolbar");

    const deleteSelect = document.getElementById("deleteSelect");
    const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const scaleModalOverlay = document.getElementById("scaleModalOverlay");
    const scalePxDistanceInfo = document.getElementById("scalePxDistanceInfo");
    const scaleKnownDistance = document.getElementById("scaleKnownDistance");
    const scaleUnit = document.getElementById("scaleUnit");
    const scaleCancelBtn = document.getElementById("scaleCancelBtn");
    const scaleConfirmBtn = document.getElementById("scaleConfirmBtn");

    const coordPanel = document.getElementById("coordPanel");

    // State
    let metersPerPixel = null;
    let scaleDisplayUnit = "meters"; // "meters" or "yards"
    let originPx = { x: 0, y: 0 };   // pixel position of origin
    let originDefined = false;
    let originCoordMeters = { x: 0, y: 0 }; // origin coordinate in meters

    let isMeasureMode = false;
    let measureStart = null;
    let measureEnd = null;
    let lastDistanceMeters = null;
    let lastCursorMeters = null; // {xm, ym} in meters (absolute)

    let isSetScaleMode = false;
    let scaleClick1 = null;
    let scaleClick2 = null;
    let scalePxDistance = null;

    let isOriginMode = false;

    // Line tool
    let isLineMode = false;
    let linePoints = [];
    let linePreviewPoint = null;

    // Circle tool
    let isCircleMode = false;
    let circleCenter = null;
    let circlePreviewPoint = null;

    // Arrow tool
    let isArrowMode = false;
    let arrowPoints = [];
    let arrowPreviewPoint = null;

    // Pen tool (freehand)
    let isPenMode = false;
    let penDrawing = false;
    let penPoints = [];

    // Widths
    let penLineWidth = 8;
    let arrowLineWidth = 8;
    const CIRCLE_LINE_WIDTH = 15;

    // Strokes
    let strokes = [];
    let strokeIdCounter = 1;

    let undoStack = [];
    let tokenIdCounter = 1;
    let isUndoing = false;

    let selectedTokens = new Set();
    let selectedStrokes = new Set();

    // Zoom state
    let baseMapWidth = null;
    let baseMapHeight = null;
    let zoomFactor = 1;
    const MIN_ZOOM = 0.25;
    const MAX_ZOOM = 6;

    // Icon scale (separate from UI scale)
    let iconScale = 1;

    function getUiScale() {
      return (
        parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--ui-scale"
          )
        ) || 1
      );
    }

    function isAnyToolActive() {
      return (
        isMeasureMode ||
        isSetScaleMode ||
        isOriginMode ||
        isLineMode ||
        isCircleMode ||
        isArrowMode ||
        isPenMode
      );
    }

    function exitAllTools() {
      exitMeasureMode();
      exitSetScaleMode();
      exitOriginMode();
      exitPenMode();
      exitLineModeConfirm(false);
      exitArrowModeConfirm(false);
      exitCircleMode();
    }

    // UI scaling
    uiScaleSelect.addEventListener("change", () => {
      const factor = parseFloat(uiScaleSelect.value) || 1.5;
      document.documentElement.style.setProperty("--ui-scale", factor);
      updateUILayout();
      updateAllTokenTransforms();
    });

    window.addEventListener("resize", () => {
      updateUILayout();
    });

    function updateUILayout() {
      const scale = getUiScale();
      const tbHeight = toolbar.offsetHeight * scale;
      mainArea.style.marginTop = tbHeight + "px";
      symbolBin.style.top = tbHeight + 10 + "px";
    }

    function updateAllTokenTransforms() {
      const tokens = mapInner.querySelectorAll(".token");
      tokens.forEach(updateTokenTransform);
    }

    function updateTokenTransform(token) {
      const rot = parseFloat(token.dataset.rotation || "0");
      const ui = getUiScale();
      const totalScale = ui * iconScale;
      token.style.transform = `scale(${totalScale}) rotate(${rot}deg)`;
      token.style.transformOrigin = "center center";
    }

    // Help / keybinds menu
    helpMenuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      helpMenu.classList.toggle("open");
    });

    document.addEventListener("click", (e) => {
      if (!helpMenu.contains(e.target) && e.target !== helpMenuBtn) {
        helpMenu.classList.remove("open");
      }
    });

    // Startup overlay
    startupMapUpload.addEventListener("change", () => {
      startupStartBtn.disabled = !startupMapUpload.files[0];
    });

    startupStartBtn.addEventListener("click", () => {
      const file = startupMapUpload.files[0];
      if (!file) {
        alert("Please choose a map file (image or PDF).");
        return;
      }
      loadMapFromFile(file);
      startupOverlay.style.display = "none";
    });

    // Icon size slider
    iconScaleSlider.addEventListener("input", () => {
      const v = parseFloat(iconScaleSlider.value);
      if (!isNaN(v) && v > 0) {
        iconScale = v;
        iconScaleValue.textContent = iconScale.toFixed(2).replace(/0+$/, "").replace(/\.$/, "") + "x";
        updateAllTokenTransforms();
      }
    });

    // Map loader (toolbar)
    mapUpload.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadMapFromFile(file);
    });

    // Scale input direct entry
    scaleInput.addEventListener("input", () => {
      const val = parseFloat(scaleInput.value);
      if (!val || val <= 0) {
        metersPerPixel = null;
        scaleDisplay.textContent = "";
        clearGrid();
        updateStatusBar(null);
      } else {
        metersPerPixel = val;
        scaleDisplayUnit = "meters"; // manual entry assumes meters
        updateScaleDisplay();
        drawGrid();
        if (measureStart && measureEnd) {
          const dx = measureEnd.x - measureStart.x;
          const dy = measureEnd.y - measureStart.y;
          const pxDist = Math.sqrt(dx * dx + dy * dy);
          lastDistanceMeters = pxDist * metersPerPixel;
          measureInfo.textContent =
            "Distance: " + formatDistance(lastDistanceMeters);
          updateStatusBar(lastCursorMeters);
        }
      }
    });

    function updateScaleDisplay() {
      if (!metersPerPixel) {
        scaleDisplay.textContent = "";
      } else {
        scaleDisplay.textContent =
          " (1 px = " + metersPerPixel.toFixed(4) + " m)";
      }
    }

    // Width controls
    penWidthInput.addEventListener("input", () => {
      const v = parseFloat(penWidthInput.value);
      if (v > 0 && v <= 50) {
        penLineWidth = v;
      }
    });

    arrowWidthInput.addEventListener("input", () => {
      const v = parseFloat(arrowWidthInput.value);
      if (v > 0 && v <= 50) {
        arrowLineWidth = v;
      }
    });

    // Map load helpers
    function resetMapState() {
      undoStack = [];
      clearTokens();
      clearMeasurement();
      clearStrokes();
      metersPerPixel = null;
      scaleDisplayUnit = "meters";
      originPx = { x: 0, y: 0 };
      originCoordMeters = { x: 0, y: 0 };
      originDefined = false;
      scaleInput.value = "";
      updateScaleDisplay();
      clearGrid();
      updateStatusBar(null);
      clearSelections();
      baseMapWidth = null;
      baseMapHeight = null;
      zoomFactor = 1;
      mapInner.style.transform = "scale(1)";
      mapZoomWrapper.style.width = "";
      mapZoomWrapper.style.height = "";
    }

    function loadMapFromFile(file) {
      if (!file) return;

      resetMapState();

      const type = file.type || "";
      const name = (file.name || "").toLowerCase();

      if (type === "application/pdf" || name.endsWith(".pdf")) {
        loadPdfAsImage(file);
      } else {
        loadImageFile(file);
      }
    }

    function loadImageFile(file) {
      const url = URL.createObjectURL(file);
      mapImage.onload = () => {
        syncCanvasSize();
        drawGrid();
        redrawStrokes();
      };
      mapImage.src = url;
    }

    function loadPdfAsImage(file) {
      if (!window["pdfjsLib"]) {
        alert("PDF.js failed to load. Cannot open PDF.");
        return;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        const typedArray = new Uint8Array(e.target.result);
        pdfjsLib
          .getDocument({ data: typedArray })
          .promise.then((pdf) => pdf.getPage(1))
          .then((page) => {
            const viewport = page.getViewport({ scale: 1 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            canvas.width = viewport.width;
            canvas.height = viewport.height;

            return page
              .render({ canvasContext: ctx, viewport: viewport })
              .promise.then(() => {
                const dataUrl = canvas.toDataURL("image/png");
                mapImage.onload = () => {
                  syncCanvasSize();
                  drawGrid();
                  redrawStrokes();
                };
                mapImage.src = dataUrl;
              });
          })
          .catch((err) => {
            console.error(err);
            alert("Failed to load PDF: " + err.message);
          });
      };
      reader.readAsArrayBuffer(file);
    }

    function syncCanvasSize() {
      if (!mapImage.naturalWidth || !mapImage.naturalHeight) return;

      baseMapWidth = mapImage.naturalWidth;
      baseMapHeight = mapImage.naturalHeight;

      mapImage.width = baseMapWidth;
      mapImage.height = baseMapHeight;

      [gridCanvas, drawCanvas, measureCanvas].forEach((c) => {
        c.width = baseMapWidth;
        c.height = baseMapHeight;
        c.style.width = baseMapWidth + "px";
        c.style.height = baseMapHeight + "px";
      });

      mapInner.style.width = baseMapWidth + "px";
      mapInner.style.height = baseMapHeight + "px";

      zoomFactor = 1;
      updateZoomVisuals();
    }

    function updateZoomVisuals() {
      if (!baseMapWidth || !baseMapHeight) return;
      mapInner.style.transform = `scale(${zoomFactor})`;
      mapZoomWrapper.style.width = baseMapWidth * zoomFactor + "px";
      mapZoomWrapper.style.height = baseMapHeight * zoomFactor + "px";
    }

    function canvasCoordsFromEvent(e) {
      const rect = mapInner.getBoundingClientRect();
      if (!baseMapWidth || !baseMapHeight || !rect.width || !rect.height) {
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }
      const scaleX = baseMapWidth / rect.width;
      const scaleY = baseMapHeight / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY,
      };
    }

    // Zoom (Shift + Scroll, to cursor)
    mapContainer.addEventListener(
      "wheel",
      (e) => {
        if (!baseMapWidth || !baseMapHeight) return;
        if (!e.shiftKey) return;

        e.preventDefault();
        const delta = -e.deltaY || e.wheelDelta || 0;
        if (!delta) return;

        const rect = mapContainer.getBoundingClientRect();
        const centerX = e.clientX - rect.left;
        const centerY = e.clientY - rect.top;
        const zoomChange = delta > 0 ? 1.1 : 0.9;
        applyZoom(zoomFactor * zoomChange, centerX, centerY);
      },
      { passive: false }
    );

    function applyZoom(targetZoom, centerX, centerY) {
      if (!baseMapWidth || !baseMapHeight) return;
      const prevZoom = zoomFactor;
      let newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom));
      if (newZoom === prevZoom) return;

      const rect = mapContainer.getBoundingClientRect();
      const scrollLeft = mapContainer.scrollLeft;
      const scrollTop = mapContainer.scrollTop;

      const mapCoordX = (scrollLeft + centerX) / prevZoom;
      const mapCoordY = (scrollTop + centerY) / prevZoom;

      zoomFactor = newZoom;
      updateZoomVisuals();

      const newScrollLeft = mapCoordX * newZoom - centerX;
      const newScrollTop = mapCoordY * newZoom - centerY;

      mapContainer.scrollLeft = newScrollLeft;
      mapContainer.scrollTop = newScrollTop;

      drawGrid();
      redrawStrokes();
    }

    // Grid
    function clearGrid() {
      const ctx = gridCanvas.getContext("2d");
      ctx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
    }

    function drawGrid() {
      clearGrid();
      if (!metersPerPixel || !mapImage.naturalWidth || !mapImage.naturalHeight)
        return;

      const ctx = gridCanvas.getContext("2d");
      const w = gridCanvas.width;
      const h = gridCanvas.height;

      const spacingPx = 100 / metersPerPixel;
      if (!isFinite(spacingPx) || spacingPx <= 0) return;

      ctx.save();
      ctx.clearRect(0, 0, w, h);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1;

      // Vertical lines
      for (let x = originPx.x; x <= w; x += spacingPx) {
        ctx.beginPath();
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, h);
        ctx.stroke();
      }
      for (let x = originPx.x; x >= 0; x -= spacingPx) {
        ctx.beginPath();
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, h);
        ctx.stroke();
      }

      // Horizontal lines
      for (let y = originPx.y; y <= h; y += spacingPx) {
        ctx.beginPath();
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(w, y + 0.5);
        ctx.stroke();
      }
      for (let y = originPx.y; y >= 0; y -= spacingPx) {
        ctx.beginPath();
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(w, y + 0.5);
        ctx.stroke();
      }

      ctx.restore();
    }

    // Measure tool
    measureBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before measuring.");
        return;
      }
      isMeasureMode = !isMeasureMode;
      if (isMeasureMode) {
        exitSetScaleMode();
        exitOriginMode();
        exitPenMode();
        exitLineModeConfirm(false);
        exitArrowModeConfirm(false);
        exitCircleMode();
        measureBtn.classList.add("active");
        measureInfo.textContent = "Measure: click two points on the map.";
        clearMeasurement();
      } else {
        exitMeasureMode();
      }
    });

    function exitMeasureMode() {
      if (!isMeasureMode) return;
      isMeasureMode = false;
      measureBtn.classList.remove("active");
      clearMeasurement();
      measureInfo.textContent = "";
    }

    function clearMeasurement() {
      measureStart = null;
      measureEnd = null;
      lastDistanceMeters = null;
      const ctx = measureCanvas.getContext("2d");
      ctx.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
      updateStatusBar(lastCursorMeters);
    }

    function drawMeasurementLine() {
      const ctx = measureCanvas.getContext("2d");
      ctx.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
      if (!measureStart || !measureEnd) return;

      ctx.save();
      ctx.strokeStyle = "rgba(0,255,0,0.9)";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(measureStart.x, measureStart.y);
      ctx.lineTo(measureEnd.x, measureEnd.y);
      ctx.stroke();

      ctx.fillStyle = "rgba(0,255,0,0.9)";
      [measureStart, measureEnd].forEach((pt) => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.restore();
    }

    // Scale by 2 points
    setScaleBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before setting scale.");
        return;
      }
      isSetScaleMode = !isSetScaleMode;
      if (isSetScaleMode) {
        exitMeasureMode();
        exitOriginMode();
        exitPenMode();
        exitLineModeConfirm(false);
        exitArrowModeConfirm(false);
        exitCircleMode();
        measureInfo.textContent =
          "Set Scale: click two points that are a known distance apart.";
        clearMeasurement();
        scaleClick1 = null;
        scaleClick2 = null;
        scalePxDistance = null;
        setScaleBtn.classList.add("active");
      } else {
        exitSetScaleMode();
      }
    });

    function exitSetScaleMode() {
      isSetScaleMode = false;
      setScaleBtn.classList.remove("active");
      measureInfo.textContent = "";
      scaleClick1 = null;
      scaleClick2 = null;
      scalePxDistance = null;
      const ctx = measureCanvas.getContext("2d");
      ctx.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
    }

    function showScaleModal(pxDist) {
      scaleModalOverlay.style.display = "flex";
      scalePxDistanceInfo.textContent =
        "Pixel distance between points: " + pxDist.toFixed(2) + " px";
      scaleKnownDistance.value = "";
      scaleUnit.value = "meters";
    }

    function hideScaleModal() {
      scaleModalOverlay.style.display = "none";
    }

    scaleCancelBtn.addEventListener("click", () => {
      hideScaleModal();
      exitSetScaleMode();
    });

    scaleConfirmBtn.addEventListener("click", () => {
      const d = parseFloat(scaleKnownDistance.value);
      if (!d || d <= 0 || !scalePxDistance || scalePxDistance <= 0) {
        alert("Enter a valid distance.");
        return;
      }
      let distanceMeters;
      if (scaleUnit.value === "meters") {
        distanceMeters = d;
        scaleDisplayUnit = "meters";
      } else {
        distanceMeters = d * 0.9144;
        scaleDisplayUnit = "yards";
      }
      metersPerPixel = distanceMeters / scalePxDistance;
      scaleInput.value = metersPerPixel.toFixed(4);
      updateScaleDisplay();
      drawGrid();
      updateStatusBar(lastCursorMeters);

      hideScaleModal();
      exitSetScaleMode();
    });

    // Origin tool
    originBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before setting origin.");
        return;
      }
      isOriginMode = !isOriginMode;
      if (isOriginMode) {
        exitMeasureMode();
        exitSetScaleMode();
        exitPenMode();
        exitLineModeConfirm(false);
        exitArrowModeConfirm(false);
        exitCircleMode();
        originBtn.classList.add("active");
        measureInfo.textContent =
          "Origin: click the point that should be your grid origin.";
      } else {
        exitOriginMode();
      }
    });

    function exitOriginMode() {
      isOriginMode = false;
      originBtn.classList.remove("active");
      measureInfo.textContent = "";
    }

    // Line tool
    lineBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before drawing lines.");
        return;
      }
      isLineMode = !isLineMode;
      if (isLineMode) {
        exitMeasureMode();
        exitSetScaleMode();
        exitOriginMode();
        exitPenMode();
        exitArrowModeConfirm(false);
        exitCircleMode();
        lineBtn.classList.add("active");
        measureInfo.textContent =
          "Line: left-click to add points, right-click to finish shape.";
        linePoints = [];
        linePreviewPoint = null;
        redrawStrokes();
      } else {
        exitLineModeConfirm(false);
      }
    });

    function exitLineModeConfirm(commitShape) {
      if (!isLineMode) return;

      if (commitShape && linePoints.length >= 2) {
        const stroke = {
          id: strokeIdCounter++,
          type: "polyline",
          width: penLineWidth,
          points: linePoints.slice(),
        };
        strokes.push(stroke);
        if (!isUndoing) {
          undoStack.push({ type: "strokeCreate", stroke });
        }
      }

      isLineMode = false;
      lineBtn.classList.remove("active");
      linePoints = [];
      linePreviewPoint = null;
      measureInfo.textContent = "";
      redrawStrokes();
    }

    // Circle tool
    circleBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before drawing circles.");
        return;
      }
      isCircleMode = !isCircleMode;
      if (isCircleMode) {
        exitMeasureMode();
        exitSetScaleMode();
        exitOriginMode();
        exitPenMode();
        exitLineModeConfirm(false);
        exitArrowModeConfirm(false);
        circleBtn.classList.add("active");
        measureInfo.textContent =
          "Circle: left-click center, then edge; right-click to exit.";
        circleCenter = null;
        circlePreviewPoint = null;
        redrawStrokes();
      } else {
        exitCircleMode();
      }
    });

    function exitCircleMode() {
      if (!isCircleMode) return;
      isCircleMode = false;
      circleBtn.classList.remove("active");
      circleCenter = null;
      circlePreviewPoint = null;
      measureInfo.textContent = "";
      redrawStrokes();
    }

    function handleCircleToolClick(x, y) {
      if (!circleCenter) {
        circleCenter = { x, y };
        circlePreviewPoint = null;
        measureInfo.textContent =
          "Circle: center set. Left-click edge to set radius, right-click to exit.";
      } else {
        const dx = x - circleCenter.x;
        const dy = y - circleCenter.y;
        const radius = Math.sqrt(dx * dx + dy * dy);
        if (radius > 0) {
          const stroke = {
            id: strokeIdCounter++,
            type: "circle",
            width: CIRCLE_LINE_WIDTH,
            center: { x: circleCenter.x, y: circleCenter.y },
            radius,
          };
          strokes.push(stroke);
          if (!isUndoing) {
            undoStack.push({ type: "strokeCreate", stroke });
          }
        }
        circleCenter = null;
        circlePreviewPoint = null;
        redrawStrokes();
        measureInfo.textContent =
          "Circle created. Left-click again to start a new circle, or right-click to exit.";
      }
    }

    // Arrow tool
    arrowBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before drawing arrows.");
        return;
      }
      isArrowMode = !isArrowMode;
      if (isArrowMode) {
        exitMeasureMode();
        exitSetScaleMode();
        exitOriginMode();
        exitPenMode();
        exitLineModeConfirm(false);
        exitCircleMode();
        arrowBtn.classList.add("active");
        measureInfo.textContent =
          "Arrow: left-click to add points, right-click to finish arrow.";
        arrowPoints = [];
        arrowPreviewPoint = null;
        redrawStrokes();
      } else {
        exitArrowModeConfirm(false);
      }
    });

    function exitArrowModeConfirm(commitShape) {
      if (!isArrowMode) return;

      if (commitShape && arrowPoints.length >= 2) {
        const stroke = {
          id: strokeIdCounter++,
          type: "arrow",
          width: arrowLineWidth,
          points: arrowPoints.slice(),
        };
        strokes.push(stroke);
        if (!isUndoing) {
          undoStack.push({ type: "strokeCreate", stroke });
        }
      }

      isArrowMode = false;
      arrowBtn.classList.remove("active");
      arrowPoints = [];
      arrowPreviewPoint = null;
      measureInfo.textContent = "";
      redrawStrokes();
    }

    function handleLineToolClick(x, y) {
      linePoints.push({ x, y });
      linePreviewPoint = { x, y };
      redrawStrokes();
      drawLinePreview();
    }

    function handleArrowToolClick(x, y) {
      arrowPoints.push({ x, y });
      arrowPreviewPoint = { x, y };
      redrawStrokes();
      drawArrowPreview();
    }

    // Pen tool – hold LMB to draw, release to stop
    penBtn.addEventListener("click", () => {
      if (!mapImage.naturalWidth) {
        alert("Load a map before using the pen.");
        return;
      }
      isPenMode = !isPenMode;
      if (isPenMode) {
        exitMeasureMode();
        exitSetScaleMode();
        exitOriginMode();
        exitLineModeConfirm(false);
        exitArrowModeConfirm(false);
        exitCircleMode();
        penBtn.classList.add("active");
        measureInfo.textContent =
          "Pen: hold left-click to draw, release to stop. Right-click to exit Pen.";
        penDrawing = false;
        penPoints = [];
      } else {
        exitPenMode();
      }
    });

    function exitPenMode() {
      if (!isPenMode) return;
      isPenMode = false;
      penBtn.classList.remove("active");
      penDrawing = false;
      penPoints = [];
      measureInfo.textContent = "";
      redrawStrokes();
    }

    // Map click handling (left click)
    mapInner.addEventListener("click", (e) => {
      if (isPenMode) return; // pen uses mousedown/mouseup only

      if (e.target.closest(".token")) {
        if (!isAnyToolActive()) {
          return;
        }
        return;
      }

      const { x, y } = canvasCoordsFromEvent(e);

      if (isLineMode) {
        handleLineToolClick(x, y);
        return;
      }

      if (isArrowMode) {
        handleArrowToolClick(x, y);
        return;
      }

      if (isCircleMode) {
        handleCircleToolClick(x, y);
        return;
      }

      if (isSetScaleMode) {
        handleSetScaleClick(x, y);
        return;
      }

      if (isMeasureMode) {
        handleMeasureClick(x, y);
        return;
      }

      if (isOriginMode) {
        if (!metersPerPixel) {
          alert("Set the scale before setting the origin coordinate.");
          return;
        }

        originPx = { x, y };
        originDefined = true;

        const defaultE = originCoordMeters.x || 0;
        const defaultN = originCoordMeters.y || 0;

        const eStr = prompt(
          "Enter Easting (meters) for this origin point (e.g. 3000). Leave blank for 0:",
          defaultE.toString()
        );
        const nStr = prompt(
          "Enter Northing (meters) for this origin point (e.g. 4000). Leave blank for 0:",
          defaultN.toString()
        );

        let eVal = parseFloat(eStr);
        let nVal = parseFloat(nStr);
        if (!isFinite(eVal)) eVal = 0;
        if (!isFinite(nVal)) nVal = 0;

        originCoordMeters = { x: eVal, y: nVal };

        drawGrid();
        updateStatusBar(lastCursorMeters);
        exitOriginMode();
        return;
      }

      const hitStroke = findStrokeAtPoint(x, y, 5);
      if (hitStroke) {
        clearSelections();
        selectedStrokes.add(hitStroke);
        redrawStrokes();
      } else {
        clearSelections();
      }
    });

    function handleMeasureClick(x, y) {
      if (!metersPerPixel) {
        alert("Set the scale first (or use 'Set Scale by 2 Points').");
        return;
      }

      if (!measureStart) {
        measureStart = { x, y };
        measureEnd = null;
        lastDistanceMeters = null;
        drawMeasurementLine();
        measureInfo.textContent = "Measure: first point set. Click another point.";
      } else {
        measureEnd = { x, y };
        const dx = measureEnd.x - measureStart.x;
        const dy = measureEnd.y - measureStart.y;
        const pxDist = Math.sqrt(dx * dx + dy * dy);
        lastDistanceMeters = pxDist * metersPerPixel;
        drawMeasurementLine();
        measureInfo.textContent =
          "Distance: " + formatDistance(lastDistanceMeters);
        updateStatusBar(lastCursorMeters);
      }
    }

    function handleSetScaleClick(x, y) {
      const ctx = measureCanvas.getContext("2d");

      if (!scaleClick1) {
        scaleClick1 = { x, y };
        scaleClick2 = null;
        scalePxDistance = null;
        ctx.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
        ctx.save();
        ctx.fillStyle = "rgba(255,215,0,0.9)";
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        measureInfo.textContent =
          "First scale point set. Click the second point.";
      } else {
        scaleClick2 = { x, y };
        ctx.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
        ctx.save();
        ctx.strokeStyle = "rgba(255,215,0,0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(scaleClick1.x, scaleClick1.y);
        ctx.lineTo(scaleClick2.x, scaleClick2.y);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,215,0,0.9)";
        [scaleClick1, scaleClick2].forEach((pt) => {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();

        const dx = scaleClick2.x - scaleClick1.x;
        const dy = scaleClick2.y - scaleClick1.y;
        scalePxDistance = Math.sqrt(dx * dx + dy * dy);
        showScaleModal(scalePxDistance);
      }
    }

    // Mouse move: previews + cursor status + pen drawing
    mapInner.addEventListener("mousemove", (e) => {
      if (!mapImage.naturalWidth) {
        updateStatusBar(null);
        return;
      }

      const { x, y } = canvasCoordsFromEvent(e);

      // Pen drawing
      if (isPenMode && penDrawing) {
        const last = penPoints[penPoints.length - 1];
        const dx = x - last.x;
        const dy = y - last.y;
        if (dx * dx + dy * dy > 0.5 * 0.5) {
          penPoints.push({ x, y });
          drawPenPreview();
        }
      }

      // Tool previews
      if (isLineMode && linePoints.length > 0) {
        linePreviewPoint = { x, y };
        redrawStrokes();
        drawLinePreview();
      } else if (isArrowMode && arrowPoints.length > 0) {
        arrowPreviewPoint = { x, y };
        redrawStrokes();
        drawArrowPreview();
      } else if (isCircleMode && circleCenter) {
        circlePreviewPoint = { x, y };
        redrawStrokes();
        drawCirclePreview();
      }

      if (!metersPerPixel) {
        lastCursorMeters = null;
        statusBar.textContent =
          "Cursor: (" +
          x.toFixed(1) +
          ", " +
          y.toFixed(1) +
          " px) – set scale to see coordinates";
        updateCoordPanel(null);
        return;
      }

      // Inverted Y axis: up on screen = increasing Y
      const xm = originCoordMeters.x + (x - originPx.x) * metersPerPixel;
      const ym = originCoordMeters.y - (y - originPx.y) * metersPerPixel;

      lastCursorMeters = { xm, ym };
      updateStatusBar(lastCursorMeters);
    });

    mapInner.addEventListener("mouseleave", () => {
      if (isPenMode && penDrawing) {
        finishPenStroke();
      }
      lastCursorMeters = null;
      updateStatusBar(null);
      if (isLineMode && linePoints.length > 0) {
        redrawStrokes();
        drawLinePreview();
      } else if (isArrowMode && arrowPoints.length > 0) {
        redrawStrokes();
        drawArrowPreview();
      } else if (isCircleMode && circleCenter) {
        redrawStrokes();
        drawCirclePreview();
      }
    });

    // Pen mouse down/up
    mapInner.addEventListener("mousedown", (e) => {
      if (!isPenMode) return;
      if (e.button !== 0) return;
      e.preventDefault();

      const { x, y } = canvasCoordsFromEvent(e);
      penDrawing = true;
      penPoints = [{ x, y }];
      drawPenPreview();
    });

    document.addEventListener("mouseup", (e) => {
      if (!isPenMode || !penDrawing) return;
      if (e.button !== 0) return;
      finishPenStroke();
    });

    function finishPenStroke() {
      penDrawing = false;
      if (penPoints.length >= 2) {
        const stroke = {
          id: strokeIdCounter++,
          type: "pen",
          width: penLineWidth,
          points: penPoints.slice(),
        };
        strokes.push(stroke);
        if (!isUndoing) {
          undoStack.push({ type: "strokeCreate", stroke });
        }
      }
      penPoints = [];
      redrawStrokes();
    }

    // Stroke drawing helpers
    function redrawStrokes() {
      const ctx = drawCanvas.getContext("2d");
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

      strokes.forEach((stroke) => {
        const type = stroke.type || "polyline";
        const selected = selectedStrokes.has(stroke);
        const baseColor =
          type === "circle"
            ? selected
              ? "rgba(0,255,255,0.9)"
              : "rgba(148,0,211,0.9)" // violet
            : selected
            ? "rgba(0,255,255,0.9)"
            : "rgba(255,0,0,0.9)"; // red

        if (type === "circle") {
          if (!stroke.center || !stroke.radius) return;
          const w = stroke.width || CIRCLE_LINE_WIDTH;
          const c = stroke.center;
          const r = stroke.radius;
          ctx.save();
          ctx.strokeStyle = baseColor;
          ctx.lineWidth = w;
          ctx.beginPath();
          ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        } else if (type === "arrow") {
          const pts = stroke.points;
          if (!pts || pts.length < 2) return;
          const w = stroke.width || arrowLineWidth;
          drawArrowStroke(ctx, pts, w, baseColor);
        } else {
          const pts = stroke.points;
          if (!pts || pts.length < 2) return;
          const w = stroke.width || penLineWidth;
          ctx.save();
          ctx.strokeStyle = baseColor;
          ctx.lineWidth = w;
          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) {
            ctx.lineTo(pts[i].x, pts[i].y);
          }
          ctx.stroke();
          ctx.restore();
        }
      });
    }

    function drawLinePreview() {
      if (linePoints.length === 0) return;
      const ctx = drawCanvas.getContext("2d");
      ctx.save();
      ctx.strokeStyle = "rgba(255,0,0,0.9)";
      ctx.lineWidth = penLineWidth;
      ctx.beginPath();
      ctx.moveTo(linePoints[0].x, linePoints[0].y);
      for (let i = 1; i < linePoints.length; i++) {
        ctx.lineTo(linePoints[i].x, linePoints[i].y);
      }
      if (linePreviewPoint) {
        ctx.lineTo(linePreviewPoint.x, linePreviewPoint.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawArrowStroke(ctx, pts, width, color) {
      if (!pts || pts.length < 2) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = width;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.stroke();

      const p2 = pts[pts.length - 1];
      const p1 = pts[pts.length - 2];
      const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      const headLength = 6 + width * 1.5;
      const headAngle = Math.PI / 7;

      ctx.beginPath();
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(
        p2.x - headLength * Math.cos(angle - headAngle),
        p2.y - headLength * Math.sin(angle - headAngle)
      );
      ctx.lineTo(
        p2.x - headLength * Math.cos(angle + headAngle),
        p2.y - headLength * Math.sin(angle + headAngle)
      );
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawArrowPreview() {
      if (arrowPoints.length === 0) return;
      const ctx = drawCanvas.getContext("2d");
      const pts = arrowPoints.slice();
      if (arrowPreviewPoint) {
        pts.push(arrowPreviewPoint);
      }
      drawArrowStroke(ctx, pts, arrowLineWidth, "rgba(255,0,0,0.9)");
    }

    function drawCirclePreview() {
      if (!circleCenter || !circlePreviewPoint) return;
      const ctx = drawCanvas.getContext("2d");
      const dx = circlePreviewPoint.x - circleCenter.x;
      const dy = circlePreviewPoint.y - circleCenter.y;
      const r = Math.sqrt(dx * dx + dy * dy);
      if (r <= 0) return;
      ctx.save();
      ctx.strokeStyle = "rgba(148,0,211,0.9)"; // violet
      ctx.lineWidth = CIRCLE_LINE_WIDTH;
      ctx.beginPath();
      ctx.arc(circleCenter.x, circleCenter.y, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawPenPreview() {
      redrawStrokes();
      if (penPoints.length < 2) return;
      const ctx = drawCanvas.getContext("2d");
      ctx.save();
      ctx.strokeStyle = "rgba(255,0,0,0.9)";
      ctx.lineWidth = penLineWidth;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(penPoints[0].x, penPoints[0].y);
      for (let i = 1; i < penPoints.length; i++) {
        ctx.lineTo(penPoints[i].x, penPoints[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function clearStrokes() {
      strokes = [];
      const ctx = drawCanvas.getContext("2d");
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    function findStrokeAtPoint(x, y, extraThreshold) {
      for (let i = strokes.length - 1; i >= 0; i--) {
        const stroke = strokes[i];
        const type = stroke.type || "polyline";
        const baseWidth = stroke.width || 2;
        const threshold = baseWidth / 2 + extraThreshold;

        if (type === "circle") {
          if (!stroke.center || !stroke.radius) continue;
          const dx = x - stroke.center.x;
          const dy = y - stroke.center.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (Math.abs(dist - stroke.radius) <= threshold) {
            return stroke;
          }
        } else {
          const pts = stroke.points || [];
          for (let j = 0; j < pts.length - 1; j++) {
            const p1 = pts[j];
            const p2 = pts[j + 1];
            const dist = pointToSegmentDistance(
              x,
              y,
              p1.x,
              p1.y,
              p2.x,
              p2.y
            );
            if (dist <= threshold) {
              return stroke;
            }
          }
        }
      }
      return null;
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        const dxp = px - x1;
        const dyp = py - y1;
        return Math.sqrt(dxp * dxp + dyp * dyp);
      }
      const t =
        ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
      const tClamped = Math.max(0, Math.min(1, t));
      const cx = x1 + tClamped * dx;
      const cy = y1 + tClamped * dy;
      const ddx = px - cx;
      const ddy = py - cy;
      return Math.sqrt(ddx * ddx + ddy * ddy);
    }

    function deleteStroke(stroke) {
      const idx = strokes.indexOf(stroke);
      if (idx >= 0) {
        strokes.splice(idx, 1);
        if (!isUndoing) {
          undoStack.push({ type: "strokeDelete", stroke });
        }
        redrawStrokes();
      }
    }

    // Context menu
    mapInner.addEventListener("contextmenu", (e) => {
      if (isPenMode) {
        e.preventDefault();
        exitPenMode();
        return;
      }

      if (isArrowMode) {
        e.preventDefault();
        exitArrowModeConfirm(true);
        return;
      }

      if (isLineMode) {
        e.preventDefault();
        exitLineModeConfirm(true);
        return;
      }

      if (isCircleMode) {
        e.preventDefault();
        exitCircleMode();
        return;
      }

      const token = e.target.closest(".token");
      const ctrl = e.ctrlKey || e.metaKey;

      if (isAnyToolActive()) {
        e.preventDefault();
        exitAllTools();
        return;
      }

      if (token) {
        e.preventDefault();
        handleTokenRightClickSelection(token, ctrl);
        return;
      }

      const { x, y } = canvasCoordsFromEvent(e);
      const hitStroke = findStrokeAtPoint(x, y, 5);
      if (hitStroke) {
        e.preventDefault();
        if (ctrl) {
          toggleStrokeSelection(hitStroke);
        } else {
          clearSelections();
          selectedStrokes.add(hitStroke);
          redrawStrokes();
        }
      } else {
        e.preventDefault();
        clearSelections();
      }
    });

    function handleTokenRightClickSelection(token, multi) {
      const id = assignTokenId(token);
      if (!multi) {
        clearSelections();
        selectedTokens.add(token);
        token.classList.add("selected-token");
        deleteSelect.value = id;
        measureInfo.textContent =
          "Selected icon – use ← / → arrow keys to rotate.";
      } else {
        if (selectedTokens.has(token)) {
          selectedTokens.delete(token);
          token.classList.remove("selected-token");
        } else {
          selectedTokens.add(token);
          token.classList.add("selected-token");
        }
        measureInfo.textContent =
          "Selected icons – use ← / → arrow keys to rotate.";
      }
    }

    function toggleStrokeSelection(stroke) {
      if (selectedStrokes.has(stroke)) {
        selectedStrokes.delete(stroke);
      } else {
        selectedStrokes.add(stroke);
      }
      redrawStrokes();
    }

    function clearSelections() {
      selectedTokens.forEach((t) =>
        t.classList.remove("selected-token")
      );
      selectedTokens.clear();
      selectedStrokes.clear();
      redrawStrokes();
      measureInfo.textContent = "";
    }

    // Symbols
    const symbolLabels = {
      objective: "OBJ",
      lz: "LZ",
      fob: "FOB",
    };

    symbolButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.symbol;
        createPresetToken(type);
      });
    });

    function createPresetToken(type) {
      const token = document.createElement("div");
      token.className = "token token-label symbol-" + type;
      token.textContent = symbolLabels[type] || "SYM";
      token.dataset.rotation = "0";

      mapInner.appendChild(token);
      placeTokenAtViewportCenter(token);
      registerNewToken(token);
    }

    // General / Platoon dropdowns
    if (generalDropdownBtn && generalDropdown) {
      generalDropdownBtn.addEventListener("click", () => {
        generalDropdown.classList.toggle("open");
      });
    }

    if (platoonDropdownBtn && platoonDropdown) {
      platoonDropdownBtn.addEventListener("click", () => {
        platoonDropdown.classList.toggle("open");
      });
    }

    // Infantry unit buttons
    const allInfButtons = document.querySelectorAll(".inf-unit-btn");
    allInfButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const side = btn.dataset.side || "friendly";
        const label =
          btn.dataset.label !== undefined
            ? btn.dataset.label
            : (btn.textContent.trim() || "");

        if (side === "enemy") {
          createEnemyUnitToken(label);
        } else {
          createFriendlyUnitToken(label);
        }
      });
    });

    function createFriendlyUnitToken(label) {
      const token = document.createElement("div");
      token.className = "token friendly-unit";
      token.dataset.rotation = "0";

      const box = document.createElement("div");
      box.className = "friendly-box";
      token.appendChild(box);

      if (label) {
        const idDiv = document.createElement("div");
        idDiv.className = "friendly-unit-id";
        idDiv.textContent = label;
        token.appendChild(idDiv);
      }

      mapInner.appendChild(token);
      placeTokenAtViewportCenter(token);
      registerNewToken(token);
    }

    function createEnemyUnitToken(label) {
      const token = document.createElement("div");
      token.className = "token enemy-unit";
      token.dataset.rotation = "0";

      const diamond = document.createElement("div");
      diamond.className = "enemy-diamond";
      token.appendChild(diamond);

      if (label) {
        const idDiv = document.createElement("div");
        idDiv.className = "enemy-unit-id";
        idDiv.textContent = label || "ENY INF";
        token.appendChild(idDiv);
      }

      mapInner.appendChild(token);
      placeTokenAtViewportCenter(token);
      registerNewToken(token);
    }

    // Custom symbols
    addCustomSymbolBtn.addEventListener("click", () => {
      tokenUpload.click();
    });

    tokenUpload.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);

      const token = document.createElement("div");
      token.classList.add("token");
      token.dataset.rotation = "0";

      const img = document.createElement("img");
      img.src = url;
      token.appendChild(img);

      mapInner.appendChild(token);
      placeTokenAtViewportCenter(token);
      registerNewToken(token);
      tokenUpload.value = "";
    });

    // Token positioning
    function setTokenBasePosition(token, baseX, baseY) {
      token.dataset.baseX = baseX;
      token.dataset.baseY = baseY;
      token.style.left = baseX + "px";
      token.style.top = baseY + "px";
    }

    function placeTokenAtViewportCenter(token) {
      const tokenSizeBase = 48;
      if (!baseMapWidth || !baseMapHeight) {
        setTokenBasePosition(token, 40, 40);
        return;
      }

      const containerRect = mapContainer.getBoundingClientRect();
      const innerRect = mapInner.getBoundingClientRect();

      const viewCenterX = containerRect.left + containerRect.width / 2;
      const viewCenterY = containerRect.top + containerRect.height / 2;

      let displayX = viewCenterX;
      let displayY = viewCenterY;
      if (
        viewCenterX < innerRect.left ||
        viewCenterX > innerRect.right ||
        viewCenterY < innerRect.top ||
        viewCenterY > innerRect.bottom
      ) {
        displayX = innerRect.left + innerRect.width / 2;
        displayY = innerRect.top + innerRect.height / 2;
      }

      const scaleX = baseMapWidth / innerRect.width;
      const scaleY = baseMapHeight / innerRect.height;

      let baseX =
        (displayX - innerRect.left) * scaleX - tokenSizeBase / 2;
      let baseY =
        (displayY - innerRect.top) * scaleY - tokenSizeBase / 2;

      baseX = Math.max(0, Math.min(baseX, baseMapWidth - tokenSizeBase));
      baseY = Math.max(0, Math.min(baseY, baseMapHeight - tokenSizeBase));

      setTokenBasePosition(token, baseX, baseY);
    }

    function assignTokenId(token) {
      if (!token.dataset.tokenId) {
        token.dataset.tokenId = String(tokenIdCounter++);
      }
      return token.dataset.tokenId;
    }

    function registerNewToken(token) {
      assignTokenId(token);
      makeDraggable(token);
      attachTokenClickSelect(token);
      updateTokenTransform(token);
      refreshDeleteDropdown();
      if (!isUndoing) {
        undoStack.push({ type: "create", token });
      }
    }

    function makeDraggable(element) {
      let dragging = false;
      let startBaseX = 0;
      let startBaseY = 0;
      let pointerOffsetX = 0;
      let pointerOffsetY = 0;

      element.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        if (isAnyToolActive()) return;
        e.preventDefault();

        dragging = true;

        const rect = mapInner.getBoundingClientRect();
        const scaleX =
          baseMapWidth && rect.width ? baseMapWidth / rect.width : 1;
        const scaleY =
          baseMapHeight && rect.height ? baseMapHeight / rect.height : 1;

        const pointerBase = {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY,
        };

        const currentBaseX =
          parseFloat(element.dataset.baseX) ||
          parseFloat(element.style.left) ||
          0;
        const currentBaseY =
          parseFloat(element.dataset.baseY) ||
          parseFloat(element.style.top) ||
          0;

        startBaseX = currentBaseX;
        startBaseY = currentBaseY;

        pointerOffsetX = pointerBase.x - currentBaseX;
        pointerOffsetY = pointerBase.y - currentBaseY;

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });

      function onMouseMove(e) {
        if (!dragging) return;
        const rect = mapInner.getBoundingClientRect();
        const scaleX =
          baseMapWidth && rect.width ? baseMapWidth / rect.width : 1;
        const scaleY =
          baseMapHeight && rect.height ? baseMapHeight / rect.height : 1;

        const pointerBase = {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY,
        };

        let newBaseX = pointerBase.x - pointerOffsetX;
        let newBaseY = pointerBase.y - pointerOffsetY;

        const zoom = zoomFactor || 1;
        const tokenDisplayWidth = element.offsetWidth / zoom;
        const tokenDisplayHeight = element.offsetHeight / zoom;

        const maxX = baseMapWidth - tokenDisplayWidth;
        const maxY = baseMapHeight - tokenDisplayHeight;

        newBaseX = Math.max(0, Math.min(newBaseX, maxX));
        newBaseY = Math.max(0, Math.min(newBaseY, maxY));

        setTokenBasePosition(element, newBaseX, newBaseY);
      }

      function onMouseUp() {
        if (!dragging) return;
        dragging = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);

        const endBaseX =
          parseFloat(element.dataset.baseX) ||
          parseFloat(element.style.left) ||
          0;
        const endBaseY =
          parseFloat(element.dataset.baseY) ||
          parseFloat(element.style.top) ||
          0;

        if (
          !isUndoing &&
          (endBaseX !== startBaseX || endBaseY !== startBaseY)
        ) {
          undoStack.push({
            type: "move",
            token: element,
            prevLeft: startBaseX,
            prevTop: startBaseY,
            newLeft: endBaseX,
            newTop: endBaseY,
          });
        }
      }
    }

    function attachTokenClickSelect(token) {
      token.addEventListener("click", () => {
        if (isAnyToolActive()) return;
        const id = assignTokenId(token);
        clearSelections();
        selectedTokens.add(token);
        token.classList.add("selected-token");
        deleteSelect.value = id;
        measureInfo.textContent =
          "Selected icon – use ← / → arrow keys to rotate.";
      });
    }

    function deleteToken(token) {
      const parent = token.parentNode;
      if (!parent) return;
      parent.removeChild(token);
      if (!isUndoing) {
        undoStack.push({ type: "delete", token, parent });
      }
      refreshDeleteDropdown();
    }

    function clearTokens() {
      const tokens = mapInner.querySelectorAll(".token");
      tokens.forEach((t) => t.remove());
      refreshDeleteDropdown();
    }

    function clearAllTokensWithUndo() {
      const tokens = Array.from(mapInner.querySelectorAll(".token"));
      if (tokens.length === 0) return;
      tokens.forEach((t) => t.parentNode && t.parentNode.removeChild(t));
      if (!isUndoing) {
        undoStack.push({ type: "clear", tokens, parent: mapInner });
      }
      refreshDeleteDropdown();
    }

    // Delete controls
    deleteSelectedBtn.addEventListener("click", () => {
      if (selectedTokens.size > 0 || selectedStrokes.size > 0) {
        selectedTokens.forEach((t) => deleteToken(t));
        selectedTokens.clear();
        selectedStrokes.forEach((s) => deleteStroke(s));
        selectedStrokes.clear();
        redrawStrokes();
        return;
      }

      const id = deleteSelect.value;
      if (!id) return;
      const token = mapInner.querySelector(
        '.token[data-token-id="' + id + '"]'
      );
      if (token) deleteToken(token);
    });

    clearAllBtn.addEventListener("click", () => {
      clearAllTokensWithUndo();
    });

    function refreshDeleteDropdown() {
      deleteSelect.innerHTML = '<option value="">Delete element…</option>';
      const tokens = mapInner.querySelectorAll(".token");
      tokens.forEach((token, index) => {
        const id = assignTokenId(token);
        let label;
        if (token.classList.contains("token-label")) {
          label = token.textContent.trim() || "Label";
        } else if (token.classList.contains("friendly-unit")) {
          const idNode = token.querySelector(".friendly-unit-id");
          label = idNode
            ? "Friendly " + idNode.textContent.trim()
            : "Friendly INF";
        } else if (token.classList.contains("enemy-unit")) {
          const idNode = token.querySelector(".enemy-unit-id");
          label = idNode
            ? "Enemy " + idNode.textContent.trim()
            : "Enemy INF";
        } else if (token.querySelector("img")) {
          label = "Custom icon " + (index + 1);
        } else {
          label = "Element " + (index + 1);
        }

        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = label + " (#" + id + ")";
        deleteSelect.appendChild(opt);
      });
    }

    // Undo (Ctrl+Z)
    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
        e.preventDefault();
        undoLast();
      }
    });

    function undoLast() {
      const action = undoStack.pop();
      if (!action) return;

      isUndoing = true;
      switch (action.type) {
        case "create":
          if (action.token && action.token.parentNode) {
            action.token.parentNode.removeChild(action.token);
          }
          break;
        case "delete":
          if (action.parent) {
            action.parent.appendChild(action.token);
            registerNewToken(action.token);
          }
          break;
        case "move":
          if (action.token) {
            setTokenBasePosition(action.token, action.prevLeft, action.prevTop);
          }
          break;
        case "clear":
          if (action.parent) {
            action.tokens.forEach((t) => {
              action.parent.appendChild(t);
              registerNewToken(t);
            });
          }
          break;
        case "strokeCreate":
          {
            const s = action.stroke;
            const idx = strokes.indexOf(s);
            if (idx >= 0) strokes.splice(idx, 1);
            redrawStrokes();
          }
          break;
        case "strokeDelete":
          {
            const s = action.stroke;
            if (!strokes.includes(s)) strokes.push(s);
            redrawStrokes();
          }
          break;
      }
      isUndoing = false;
      refreshDeleteDropdown();
    }

    // Rotate selected tokens
    document.addEventListener("keydown", (e) => {
      if (selectedTokens.size === 0) return;
      let delta = 0;
      if (e.key === "ArrowLeft") {
        delta = -5;
      } else if (e.key === "ArrowRight") {
        delta = 5;
      } else {
        return;
      }
      e.preventDefault();
      selectedTokens.forEach((token) => {
        const current = parseFloat(token.dataset.rotation || "0");
        const next = current + delta;
        token.dataset.rotation = String(next);
        updateTokenTransform(token);
      });
    });

    // Coordinate + status bar
    function formatDistance(dMeters) {
      if (scaleDisplayUnit === "yards") {
        const dYds = dMeters / 0.9144;
        return dYds.toFixed(1) + " yd";
      }
      return dMeters.toFixed(1) + " m";
    }

    function updateCoordPanel(cursorMeters) {
      if (!metersPerPixel || !originDefined || !cursorMeters) {
        coordPanel.textContent = "X: –, Y: –";
        return;
      }
      let xm = cursorMeters.xm;
      let ym = cursorMeters.ym;
      let unitLabel = "m";
      if (scaleDisplayUnit === "yards") {
        xm = xm / 0.9144;
        ym = ym / 0.9144;
        unitLabel = "yd";
      }

      // round to nearest 5 in displayed units
      const roundedX = Math.round(xm / 5) * 5;
      const roundedY = Math.round(ym / 5) * 5;

      coordPanel.textContent =
        "X: " +
        roundedX.toFixed(0) +
        " " +
        unitLabel +
        ", Y: " +
        roundedY.toFixed(0) +
        " " +
        unitLabel;
    }

    function updateStatusBar(cursorMeters) {
      let coordPart;
      if (!mapImage.naturalWidth) {
        coordPart = "Cursor: – (load a map)";
      } else if (!metersPerPixel) {
        coordPart = "Cursor: – (set scale)";
      } else if (!cursorMeters) {
        coordPart = "Cursor: –";
      } else {
        let xm = cursorMeters.xm;
        let ym = cursorMeters.ym;
        let unitLabel = "m";
        if (scaleDisplayUnit === "yards") {
          xm = xm / 0.9144;
          ym = ym / 0.9144;
          unitLabel = "yd";
        }

        // Grid bands from origin, 1000m each
        const relE = cursorMeters.xm - originCoordMeters.x;
        const relN = cursorMeters.ym - originCoordMeters.y;

        let eGrid = Math.floor(relE / 1000) + 1;
        let nGrid = Math.floor(relN / 1000) + 1;
        if (eGrid < 1) eGrid = 1;
        if (nGrid < 1) nGrid = 1;

        coordPart =
          "Cursor: X=" +
          xm.toFixed(1) +
          " " +
          unitLabel +
          ", Y=" +
          ym.toFixed(1) +
          " " +
          unitLabel +
          " | Grid: E" +
          eGrid +
          ", N" +
          nGrid;
      }

      let distPart = "";
      if (lastDistanceMeters != null) {
        distPart = " | Last distance: " + formatDistance(lastDistanceMeters);
      }

      statusBar.textContent = coordPart + distPart;
      updateCoordPanel(cursorMeters);
    }

    // Initial layout
    updateUILayout();
  </script>
    <!-- your existing HTML code here -->

    <script>
    document.addEventListener('DOMContentLoaded', function () {
      // Show only once per browser (per device)
      if (localStorage.getItem('uiScaleNoticeShown') === 'true') return;

      // Create banner container
      const banner = document.createElement('div');
      banner.style.position = 'fixed';
      banner.style.top = '0';
      banner.style.left = '0';
      banner.style.right = '0';
      banner.style.zIndex = '9999';
      banner.style.padding = '10px 16px';
      banner.style.backgroundColor = '#222';
      banner.style.color = '#fff';
      banner.style.fontFamily = 'sans-serif';
      banner.style.fontSize = '14px';
      banner.style.display = 'flex';
      banner.style.justifyContent = 'space-between';
      banner.style.alignItems = 'center';
      banner.style.boxShadow = '0 2px 6px rgba(0,0,0,0.4)';

      const message = document.createElement('span');
      message.textContent = 'Tip: For best results, set the initial UI scale to 0.5 in the settings.';
      banner.appendChild(message);

      const button = document.createElement('button');
      button.textContent = 'Got it';
      button.style.marginLeft = '16px';
      button.style.padding = '4px 10px';
      button.style.border = 'none';
      button.style.borderRadius = '4px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '13px';
      button.onclick = function () {
        localStorage.setItem('uiScaleNoticeShown', 'true');
        banner.remove();
      };
      banner.appendChild(button);

      document.body.appendChild(banner);
    });
    </script>

</body>
</html>



